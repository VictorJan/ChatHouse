# ChatHouse
A web application for secure end-to-end encrypted real time conversations , with storing capabilities. Moreover the app supports a secure authentication (which is token based) process - which involves 2 factor authentication ,as for creating an account/logging in. Apart from that, a user is to be allowed to safely change the state of the account - the password, or even discharge/delete the account - by relying on the additional verification step , mentioned before.

Running on your own.
In order to run this application one would have to provide necessary configuration details for the config.json - regarding the STATIC_KEY - a static key for signing the JWT tokens  , then MAIL_USERNAME and MAIL_PASSWORD - email credentials , and DH_GENERATOR,DH_MODULUS - Diffie Hellman protocol parameters.

More about the app:

Let's talk about the security in the IAA - Identification Authentication Authorization, itself. When somebody wishes to sign up/sign in - they shall be identified based on the initial goal, by providing necessary credentials. Then an email is to be sent to the provided email address, if the goal was to sign up (respectively carrying out a check for the absence of an already registered account with the latter inputed unique credentials, such as - email address or username) otherwise based on the provided identification - assuming the goal was to sign in.
The email itself contains a verification token - which is valid for several minutes , which is also revoked after a successful use.
The verification token - allows a user to resume to the next step - password submission - the Authentication step in the login flow. After having submited a password - a user then is presented with a JWT grant token, which could be used to fetch authorized views - pages and access tokens , which on their own are used to make Authorized actions regarding searching,creating and updating data.

Having created an account - a user is welcomed with already established "self chat" - a storage type of chat - named "Saved messages", which only consists of the user as a participant - thus all messages sent in the latter chat is encrypted with the user's private key.

Private Keys and Keyrings:
Having authenticated and authorized themselves, users are presented with their raw private keys in their keyrings , which have been decrypted during the authentication/providing the password - the unhashed password being a key for symmetric encryption & decryption. Once a users wishes to enter a chat, where they are stated as a participant / authorized - client fetches public keys of all of the participants , and establishes a common secret key , using the other participant's public key - by performing the Diffie Hellman protocol, then such key is stored in memmory to encrypt future messages.

Estalishing a chat:
If the user wishes to establish/create a chat - they would have to open the profile -> utilities menu - by clicking on their username at the top-middle-left side of their screen. Then having moved to the Utilities - proceed to click on the bottom left button. Then a user may create a chat , by entering a name for a chat, and choosing another participant(optional) - by searching for them, inputing the username/name. Having decided on the name and the participant (again,optional) - if the establishment of the chat has been successful - both of the users are to receive notifications - a new chat in their chatlist,on the left.

Entering a chat , sending/removing messages and discharging the chat.
By sending a simple GET request to the ?chat_id=some id , or just clicking the arrow button on the respective chat - would load in the page, and connect the client to a certain chat socket namespace - access to which must be authorized, by providing an access token and the cha it, if the token is invalid - the client tries to "refresh" access (Look below for more information), reestablishing the connection once more. Now at this point a user may be able to send/remove messages, such actions send separate "notifications" to each participant, via a room in the notification namespace, similar to the chat establishment. As the readme has previously stated - the communication is end-to-end encrypted, so when a user sends a message - such message is encrypted using AES CBC algorithm with the established common key / private key (in case of the "self chat"). Imporant to note that - the policy of each chat allows any participant to remove ANY message of the chat and discharge a related chat at any point of time.

Account utilities.
Account removal:
A user is allowed to discharge/remove their account, by clicking the top left button in the utilities menu. This would send a POST request /w proper payload aimed at token/confirmation, to create and send an email with a link to a confirmation url /w a confirmation token - to the user's email address, if the access token and the payload - provided in the request have been valid. Such token has a short lifetime , and as other tokens that allow authorized actions - is revoked after it's use. When the mail is sent, the user is notified, that they are going to be logged out. Then, the last step of the account discharge - is to visit the link, which would load a page , if the confirmation token is still valid, containing a password field - where the user enters the password and confirms their decision - which sends a DELETE request at the users/user's id , providing the hashed password and the confirmation token. 

Password reset:
A user is allowed to change their account, by clicking the top left button in the utilities menu. This would also send a POST request /w proper payload aimed at token/confirmation, to create and send an email with a link to a confirmation url /w a confirmation token - to the user's email address, if the access token and the payload - provided in the request have been valid. Such token has a short lifetime , and as other tokens that allow authorized actions - is revoked after it's use. When the mail is sent, the user is notified, that they are going to be logged out. Then, the last step of the password reset - is to visit the link, which would load a page , if the confirmation token is still valid, containing a 2 password fields, one for the current password and the other one for the new one. Confirming the action - sends a PUT request at the users/user's id , providing the hashed passwords , the confirmation token and the new private key - which is established right before the call, by fetching the current keyring -> decrypting and encrypting it with the new raw password. 

What happens when the access token is invalid?
Well the client tries to "refresh" it , by sending a request to a /token/access REST API endpoint - providing the grant token. If the grant token is still valid - the access token is returned to the client, which let's them continue their initial actions.

